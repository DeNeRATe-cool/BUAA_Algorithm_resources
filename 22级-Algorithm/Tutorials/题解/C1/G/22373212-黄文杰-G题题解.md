1.  读完题目，发现是很简单的问题。

2.  每个流星雨的出现时期可以由Si+k*di（k=0,1,2,3...）得到，用所有的流星雨的出现时间对一个足够大的数组进行赋值，写入流星雨的编号，（没有流星雨出现的日期赋0即可），并且要求提供的流星雨编号是最小的那一个，而且对日期数组进行赋值的时候是按流星雨编号从小到大进行赋值的，说明如果一个日期已经被某个流星雨“赋值”了，那么后续即使再有其他流星雨在此日期出现也不必再次赋值。

3.  对日期数组赋完值后，从日期t开始检索到的第一个非0的日期数组元素即是能观测到的流星雨的最小编号，其日期便是日期数组的位置。

4.  能够按照上述方法做的原因是：这道题好像没怎么卡时间，优化的方案是计算每个流星雨出现日期并赋值的时候，如果此日期已经大于日期t就停止计算，然后进行下一个流星雨的出现日期。

源代码：
#include <stdio.h>
int date[200010]={0};
int main()
{
    int n,t;
    scanf("%d %d",&n,&t);
    int s,d;
    for(int i=1;i<=n;i++)
    {
        scanf("%d %d",&s,&d);
        for(int j=s;j<=200000;j+=d)
        {
            if(date[j]==0)date[j]=i;
            if(j>=t)break;
        }
    }
    for(int i=t;i<=200000;i++)
    {
        if(date[i]!=0)
        {
            printf("%d %d\n",i,date[i]);
            break;
        }
    }
    return 0;
}


