# 算法模板

## base

```c++
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using db = long double;  // or double, if TL is tight
using str = string;
using u32 = unsigned int;
using u64 = unsigned long long;
using u128 = unsigned __int128;

using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pdd = pair<db, db>;
#define fi first
#define se second

#define vc vector
using vi = vc<int>;
using vb = vc<bool>;
using vll = vc<ll>;
using vd = vc<db>;
using vs = vc<str>;
using vch = vc<char>;
using vpii = vc<pii>;
using vpll = vc<pll>;
using vpdd = vc<pdd>;
using vvi = vc<vc<int>>;
using vvll = vc<vc<ll>>;
using vvch = vc<vc<char>>;
using vvb = vc<vc<bool>>;
using vvpii = vc<vc<pii>>;
using vvpll = vc<vc<pll>>;
using vvvi = vc<vc<vc<int>>>;

const int mod = 998244353;  // 1e9 + 7;
const int INF = 0x3f3f3f3f;
const ll BIG = 1e18;  // not too close to LLONG_MAX
const db PI = acos((db)-1);
const int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};  // for every grid problem!!
mt19937 rng32((uint32_t)chrono::steady_clock::now().time_since_epoch().count());
mt19937_64 rng64((uint64_t)chrono::steady_clock::now().time_since_epoch().count());

#define cl(x, y) memset(x, y, sizeof(x))
#define de(x) cerr << #x << " = " << x << " "
#define del(x) cerr << #x << " = " << x << endl

#define overload3(a, b, c, d, ...) d
#define rep1(a) for(int i = 0; i < (a); i++)
#define rep2(i, a) for (int i = 0; i < (a); i++)
#define rep3(i, a, b) for (int i = (a); i <= (b); i++)
#define per1(a) for(int i = (a) - 1; i >= 0; i--)
#define per2(i, a) for (int i = (a) - 1; i >= 0; i--)
#define per3(i, a, b) for (int i = (a); i >= (b); i--)
#define rep(args...) overload3(args, rep3, rep2, rep1)(args)
#define per(args...) overload3(args, per3, per2, per1)(args)
#define for_subset(t, s) \
    for (ll t = (s); t >= 0; t = (t == 0 ? -1 : (t - 1) & (s)))

#define co cout
#define dl '\n'
#define ret return
#define pb push_back
#define tcT template <class T
#define YES cout << "YES" << endl
#define Yes cout << "Yes" << endl
#define NO cout << "NO" << endl
#define No cout << "No" << endl
#define INT(args...) \
    int args;        \
    rd(args)
#define LL(args...) \
    ll args;        \
    rd(args)

#define all(s) s.begin(), s.end()
#define rall(s) s.rbegin(), s.rend()
#define sz(v) int(v.size())
#define SUM(a) accumulate(all(a), 0ll)
#define MIN(v) (*min_element(all(v)))
#define MAX(v) (*max_element(all(v)))
#define unisort(v) \
    sort(all(v));  \
    v.resize(unique(all(v)) - v.begin())

int popcnt(int x) { return __builtin_popcount(x); }
int popcnt(u32 x) { return __builtin_popcount(x); }
int popcnt(ll x) { return __builtin_popcountll(x); }
int popcnt(u64 x) { return __builtin_popcountll(x); }

#define LOWBIT(x) ((x) & (-x))
// (0, 1, 2, 3, 4) -> (-1, 0, 1, 1, 2)
int topbit(int x) { return (x == 0 ? -1 : 31 - __builtin_clz(x)); }
int topbit(u32 x) { return (x == 0 ? -1 : 31 - __builtin_clz(x)); }
int topbit(ll x) { return (x == 0 ? -1 : 63 - __builtin_clzll(x)); }
int topbit(u64 x) { return (x == 0 ? -1 : 63 - __builtin_clzll(x)); }
// (0, 1, 2, 3, 4) -> (-1, 0, 1, 0, 2)
int lowbit(int x) { return (x == 0 ? -1 : __builtin_ctz(x)); }
int lowbit(u32 x) { return (x == 0 ? -1 : __builtin_ctz(x)); }
int lowbit(ll x) { return (x == 0 ? -1 : __builtin_ctzll(x)); }
int lowbit(u64 x) { return (x == 0 ? -1 : __builtin_ctzll(x)); }
tcT > T cdiv(T &a, T &b) {
    return a / b + ((a ^ b) > (T)(0) && a % b);
}  // divide a by b rounded up
tcT > T fdiv(T &a, T &b) {
    return a / b - ((a ^ b) < (T)(0) && a % b);
}  // divide a by b rounded down

tcT, class S > inline ostream &operator<<(ostream &i, const pair<T, S> &a) { return i << a.first << ' ' << a.second; }
tcT, class S > inline istream &operator>>(istream &i, pair<T, S> &a) { return i >> a.first >> a.second; }
tcT > inline ostream &operator<<(ostream &i, const vector<T> &a) {
    if (a.size())
        i << a[0];
    for (int j = 1; j < int(a.size()); j++)
        i << ' ' << a[j];
    return i;
}
tcT > inline istream &operator>>(istream &i, vector<T> &a) {
    for (auto &j : a)
        i >> j;
    return i;
}
void err(istream_iterator<string> it) { it.~istream_iterator(); }
template <typename T, typename... Args>
void err(istream_iterator<string> it, T a, Args... args) {
    cerr << *it << " = " << a << endl;
    err(++it, args...);
}
void wt() { cout << '\n'; }
tcT, class... Args > void wt(const T &a, const Args &...args) {
    cout << a;
    (void)(cout << ... << (cout << ' ', args));
    cout << '\n';
}
tcT > void wt(vector<vector<T>> &a) {
    for (auto &i : a)
        wt(i);
}
tcT, class S > void wt(vector<pair<T, S>> &a) {
    for (auto &i : a)
        wt(i);
}
template <class... T>
void rd(T &...a) { (cin >> ... >> a); }

#define LOCAL_TEST freopen("out.txt", "w", stdout)
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
#define FIX(x) cout << fixed << setprecision(x)

const int maxn = 1e5 + 5;

inline void INIT() {

}

inline void SOLVE() {

    

}

/*

*/

int main() {

    IOS; FIX(20);

    INIT();
    int tt = 1;
    cin >> tt;
    while(tt--)
        SOLVE();

    // cout << "program ends..." << endl;
    // system("pause");
    return 0;
}
```

## Fun1

```c++
auto  = [&]() ->  {

};
```

## Fun2

```c++
auto  = [&](auto &&self) ->  {

};
```

## heap

> constructed by C

```c
#define maxn 100005

#define lson (x << 1 | 1)
#define rson ((x + 1) << 1)
#define fa ((x - 1) >> 1)

int n;

void swap(int *ARR, int x, int y) {
	int temp = ARR[x];
	ARR[x] = ARR[y];
	ARR[y] = temp;
}

void heap_adjust(int * ARR, int x) {
	
	int temp = ARR[x];
	while(lson < n) {
		if(rson < n && ARR[rson] > ARR[lson] && ARR[rson] > temp) {
			ARR[x] = ARR[rson];
			x = rson;
		} else if(ARR[lson] > temp) {
			ARR[x] = ARR[lson];
			x = lson;
		} else break;
	}
	ARR[x] = temp;
}

void heap_sort(int * ARR) {
	per(i, n / 2 - 1, 0) 
		heap_adjust(ARR, i, n);
	
	// for sorting
		
//	per(i, n - 1, 1) {
//		swap(ARR, 0, i);
//		heap_adjust(ARR, 0, i);
//	}
}

int top(int *ARR) {
	return ARR[0];
}

void pop(int *ARR) {
	ARR[0] = ARR[n - 1];
	n--;
	heap_adjust(ARR, 0);
}

void del(int *ARR, int x) {
	swap(ARR, x, n - 1);
	n--;
	heap_adjust(ARR, x);
}

void increase(int *ARR, int x, int val) {
	ARR[x] = val;
	while(x > 0 && ARR[fa] < ARR[x]) {
		swap(ARR, fa, x);
		x = fa;
	}	
}

void push(int *ARR, int val) {
	ARR[n++] = int(-1e9);
	increase(ARR, n - 1, val);	
}

void delete_by_val(int *ARR, int x) {
	rep(i, 0, n - 1) {
		if(ARR[i] == x) {
			ARR[i] = ARR[n - 1];
			n--;
			heap_adjust(ARR, i);
			while(i > 0 && ARR[(i - 1) >> 1] < ARR[i]) {
				swap(ARR, (i - 1) >> 1, i);
				i = ((i - 1) >> 1);
			}
			break;
		}
	}
}
```

## sort

> All kinds of sort algorithm

```c
void swap(int * ARR, int i, int j) {
	int tmp = ARR[i];
	ARR[i] = ARR[j];
	ARR[j] = tmp;
}

// 插入排序：按顺序选择，插入到前边已经排好的里边

// 选择后边最小的放到前边来
void select_sort(int * ARR, int n) {
	rep(i, 0, n - 2) {
		int loc = i;
		rep(j, i + 1, n - 1) {
			if(ARR[j] < ARR[loc]) 
				loc = j;
		}
		swap(ARR, loc, i);
	}
}

void bubble_sort(int * ARR, int n) {
	int flag = 1;
	for(int i = n - 1; i >= 1 && flag; i--) {
		flag = 0;
		rep(j, 0, i - 1) {
			if(ARR[j] > ARR[j + 1])
				swap(ARR, j, j + 1),
				flag = 1;
		}
	}
} 

void heap_adjust(int * ARR, int x, int n) {
	#define lson (x << 1 | 1)
	#define rson ((x + 1) << 1)
	#define fa ((x - 1) >> 1)
	
	int temp = ARR[x];
	while(lson < n) {
		if(rson < n && ARR[rson] > ARR[lson] && ARR[rson] > temp) {
			ARR[x] = ARR[rson];
			x = rson;
		} else if(ARR[lson] > temp) {
			ARR[x] = ARR[lson];
			x = lson;
		} else break;
	}
	ARR[x] = temp;
	#undef lson rson fa
}

void heap_sort(int * ARR, int n) {
	per(i, n / 2 - 1, 0) 
		heap_adjust(ARR, i, n);
		
	per(i, n - 1, 1) {
		swap(ARR, 0, i);
		heap_adjust(ARR, 0, i);
	}
}

void merge_arr(int * ARR, int * tmp, int n, int l, int r) {
	if(l >= r) return;
	int mid = (l + r) >> 1;
	
	merge_arr(ARR, tmp, n, l, mid);
	merge_arr(ARR, tmp, n, mid + 1, r);
	
	int posl = l, posr = mid + 1, loc = l;
	while(posl <= mid && posr <= r) {
		if(ARR[posl] <= ARR[posr])
			tmp[loc++] = ARR[posl++];
		else tmp[loc++] = ARR[posr++];
	}	
	while(posl <= mid) tmp[loc++] = ARR[posl++];
	while(posr <= r) tmp[loc++] = ARR[posr++];
	rep(i, l, r) ARR[i] = tmp[i];
}

void merge_sort(int * ARR, int n) {
	int * tmp = (int *)malloc(sizeof(int) * n);
	merge_arr(ARR, tmp, n, 0, n - 1);
	free(tmp);
}

void quick(int * ARR, int n, int l, int r) {
	if(l >= r) return;
	
	int loc = l;
	rep(i, l + 1, r) {
		if(ARR[i] < ARR[l])
			swap(ARR, ++loc, i);
	}
	swap(ARR, l, loc);
	quick(ARR, n, l, loc - 1);
	quick(ARR, n, loc + 1, r);
}

void quick_sort(int * ARR, int n) {
	quick(ARR, n, 0, n - 1);
}
```

## Prime

```c++
vi minp, prime;

void sieve(int n) {
    minp.assign(n + 1, 0);
    prime.clear();
    
    for (int i = 2; i <= n; i++) {
        if (minp[i] == 0) {
            minp[i] = i;
            prime.push_back(i);
        }
        
        for (auto p : prime) {
            if (i * p > n) {
                break;
            }
            minp[i * p] = p;
            if (p == minp[i]) {
                break;
            }
        }
    }
}
```

## 逆元

```c++
iv[0] = iv[1] = 1;
fc[0] = fc[1] = 1;
rep(i, 2, lim) {
    iv[i] = (mod - mod / i) * iv[mod % i] % mod;
    fc[i] = fc[i - 1] * i % mod;
}
ic[lim] = ft(fc[lim], mod - 2);
per(i, lim - 1, 0) ic[i] = ic[i + 1] * (i + 1) % mod;
```

## Hash

```c++
using ull = unsigned long long;
using haxi = pair<ull, ull>;

// 双哈希，using haxi = pair<ull, ull>; pair 自带重载的 ==, != 运算符
// 第一重哈希固定 base = 17477417（质数），模数为 2^64（ull 的自然溢出）
// 第二重哈希使用 randbase，模数为 1e9+7（质数）保证其安全性
// 最终等价于一个模数的量级为 10^27 的哈希，自然的哈希冲突（生日悖论）几乎完全不可能造成冲突
// 哈希过程为倒着哈希，s[0]*p**(n-1)+s[1]*p**(n-2)+...+s[n-1]*p**0

// 初始化可以用一个字符串进行初始化，也可以不初始化，之后用 extend 函数把字符串拼上去
// val() 返回整个字符串的哈希值，如果单纯只要一个字符串的哈希值不需要存储，可以这样 auto val = Hash(str).val();

ull randbase = rn64g() % 20240327;
struct Hash {
    const ull p1 = 17477417, p2 = randbase + 131;
    const ull mod2 = 1e9 + 7;
    vector<haxi> pw, pre;
    haxi val(void) { return pre.back(); }
    haxi val(int l, int r) { // 从0开始，[l,r)
        haxi ans;
        ans.first = pre[r].first - pre[l].first * pw[r - l].first;
        ans.second = (pre[r].second + mod2 - pre[l].second * pw[r - l].second % mod2) % mod2;
        return ans;
    }
    size_t size() { return pw.size() - 1; }
    // 部分位置为了追求效率，传的是引用，如果要进行 extend(a+b) 这种操作的话改成传值
    void extend(string &s) {
        int n = int(pw.size()), m = int(s.size());
        pw.resize(n + m);
        pre.resize(n + m);
        for (int i = n; i < n + m; ++i) {
            pw[i].first = pw[i - 1].first * p1;
            pw[i].second = pw[i - 1].second * p2 % mod2;
        }
        for (int i = n; i < n + m; ++i) {
            pre[i].first = pre[i - 1].first * p1 + s[i - n];
            pre[i].second = (pre[i - 1].second * p2 + s[i - n]) % mod2;
        }
    }
    Hash(string &s) : pw(s.size() + 1), pre(s.size() + 1)
    {
        pw[0] = haxi(1, 1);
        for (int i = 1; i <= int(s.size()); ++i)
        {
            pw[i].first = pw[i - 1].first * p1;
            pw[i].second = pw[i - 1].second * p2 % mod2;
        }
        for (int i = 1; i <= int(s.size()); ++i)
        {
            pre[i].first = pre[i - 1].first * p1 + s[i - 1];
            pre[i].second = (pre[i - 1].second * p2 + s[i - 1]) % mod2;
        }
    }
    Hash() : pw(1), pre(1) { pw[0] = {1, 1}; }
};
```

## 离散化

```c++
template<typename T>
vector<T> DDT(vector<T> &arr, bool sta = 0) {
    // data discreted value start from {sta}
    /*
        value_range
            sta = 0: [0, sz(id))
            sta = 1: [1, sz(id))
    */
    vector<T> id(arr);
    sort(id.begin(), id.end());
    int siz = unique(id.begin(), id.end()) - id.begin();
    id.resize(siz);
    for(auto &a: arr) a = lower_bound(id.begin(), id.end(), a) - id.begin() + sta;
    if(sta) id.insert(id.begin(), 0);
    return id;
}
```

## Dijkstra

```c++
/*
    @param  'sta' the source point
            'n' total points
            'edge' type vector<vector<pair<int, int>>>, stores the edge info(next point and the value)
    @return 'dis' the distance vector of the source point
*/
inline vll dijkstra(int sta, int n, vvpii &edge) {
    vll dis(n, 0x3f3f3f3f3f3f3f3f); dis[sta] = 0;
    vb jud(n);
    priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> q;
    q.push(pll{dis[sta], sta});
    while(!q.empty()) {
        pair<ll, int> now = q.top();
        q.pop();
        if(jud[now.second]) continue;
        jud[now.second] = true;
        for(auto &[ed, val]: edge[now.second]) {
            if(dis[ed] > now.first + val) {
                dis[ed] = now.first + val;
                q.push(make_pair(dis[ed], ed));
            }
        }
    }
    return dis;
}
```

## SPFA

```c++
/*
    @param  'sta' the source point
            'n' total points
            'g' type vector<vector<pair<int, int>>>, stores the edge info(next point and the value)
            '&negLoop' if the graph has negative loop
    @return 'dis' the distance vector of the source point
*/
inline vll spfa(int sta, int n, vvpii &g, bool &negLoop) {
    vi cnt(n); negLoop = false;
    vll dis(n, 0x3f3f3f3f3f3f3f3f); dis[sta] = 0;
    vb vis(n); vis[sta] = true;
    queue<int> q; q.push(sta); cnt[sta] += 1;
    while(!q.empty()) {
        int now = q.front(); q.pop();
        vis[now] = false;
        for(auto [ed, val]: g[now]) {
            if(dis[ed] > dis[now] + val) {
                dis[ed] = dis[now] + val;
                if(!vis[ed]) {
                    q.push(ed);
                    vis[ed] = true;
                    if(++cnt[ed] >= n + 1) {
                        negLoop = true;
                        return dis;
                    } 
                }
            }
        }
    }
    return dis;
}
```

## prim

$O(n + m) \log n$

Kruskal为 $O(m \log m)$

```c++
const int maxn = 5e3 + 10, maxm = 2e5 + 10;

int total, side, u, v, w, opt;
int nxt[maxm << 1], head[maxn], ed[maxm << 1], cur, val[maxm << 1];
int dist[maxn], cnt, sum;
bool jud[maxn];
priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > >mine;

inline void solve() {
    cl(dist, 0x3f);
    dist[1] = 0;
    mine.push(make_pair(dist[1], 1));
    while(!mine.empty()) {
        pair<int, int>now = mine.top();
        mine.pop();
        if(jud[now.second]) continue;
        jud[now.second] = true;
        sum += now.first;
        for(int i = head[now.second]; i; i = nxt[i]) 
            if(dist[ed[i]] > val[i]) {
                dist[ed[i]] = val[i];
                mine.push(make_pair(dist[ed[i]], ed[i]));
            }
    }
}

inline void add_edge(int from, int to, int temp) { 
    nxt[++cur] = head[from]; 
    head[from] = cur; 
    ed[cur] = to; 
    val[cur] = temp; 
}

inline void Main() {
    scanf("%d %d", &total, &side);
    rep(i, 1, side) { scanf("%d %d %d", &u, &v, &w); add_edge(u, v, w); add_edge(v, u, w); }
    solve();
    printf("%d\n", sum);
}   
```

## FHQ_Treap

```c++
struct FHQ_Treap {
    int root, cnt, _x, _y, _z;
    vector<int> weight, val, siz;
    vector<vector<int>> child;

    FHQ_Treap(int n): weight(n + 1), val(n + 1), siz(n + 1), child(n + 1, vector<int>(2)) {
        root = cnt = 0;
    }
    void clear() { root = 0, cnt = 0; }
    int size() { return siz[root]; }

    #define lson child[x][0]
    #define rson child[x][1]
    int new_node(int x) { cnt++, weight[cnt] = rng(), val[cnt] = x, siz[cnt] = 1, child[cnt][0] = child[cnt][1] = 0; return cnt; }
    void update(int x) { siz[x] = siz[lson] + siz[rson] + 1; }
    void split(int x, int lim, int &a, int &b) { // split by value
        if(!x) { a = b = 0; return; }
        if(val[x] <= lim) { a = x; split(rson, lim, rson, b); }
        else { b = x; split(lson, lim, a, lson); }
        update(x);
    }
    int merge(int a, int b) {
        if(!a || !b) { return (a | b); }
        if(weight[a] < weight[b]) { child[a][1] = merge(child[a][1], b); update(a); return a; }
        else { child[b][0] = merge(a, child[b][0]); update(b); return b; }
    }
    int rank(int x, int lim) { // which one with rank lim
        while(true) {
            if(siz[lson] >= lim) { x = lson; }
            else if(siz[lson] + 1 == lim) { return val[x]; }
            else lim -= siz[lson] + 1, x = rson;
        }
    }

    // operating with interval
    void push_down(int x) {  } // play with "merge" and "split" added "push_down" operation
    void split_by_size(int x, int lim, int &a, int &b) {
        if(!x) { a = b = 0; return; }
        // push_down(x);
        if(siz[lson] >= lim) { b = x; split_by_size(lson, lim, a, lson); }
        else { a = x; split_by_size(rson, lim - siz[lson] - 1, rson, b); }
        update(x);
    }
    #undef lson rson

    void insert(int t) { split(root, t - 1, _x, _y); root = merge(merge(_x, new_node(t)), _y); }
    void erase(int t) { split(root, t - 1, _x, _y); split(_y, t, _y, _z); root = merge(merge(_x, merge(child[_y][0], child[_y][1])), _z); }
    int rank_of_value(int t) { split(root, t - 1, _x, _y); int res = siz[_x] + 1; root = merge(_x, _y); return res;  }
    pair<int, bool> value_of_rank(int t) { if(t > siz[root] || t < 1) return {0, false}; return {rank(root, t), true}; } // val & err
    int greater_lower(int t) { int res = siz[root]; split(root, t - 1, _x, _y); res -= siz[_x]; root = merge(_x, _y); return res;  } // greater with itself
    int greater_upper(int t) { int res = siz[root]; split(root, t, _x, _y); res -= siz[_x]; root = merge(_x, _y); return res; } // greater than t
    int less_lower(int t) { split(root, t, _x, _y); int res = siz[_x]; root = merge(_x, _y); return res; } // less with itself
    int less_upper(int t) { split(root, t - 1, _x, _y); int res = siz[_x]; root = merge(_x, _y); return res; } // less than t
    int before(int t) { split(root, t - 1, _x, _y); int res = rank(_x, siz[_x]); root = merge(_x, _y); return res; } // the last one less than t
    int later(int t) { split(root, t, _x, _y); int res = rank(_y, 1); root = merge(_x, _y); return res; } // the first one greater than t
    int Max() { return rank(root, siz[root]); }
    int Min() { return rank(root, 1); }

};
```

## FFT

```c++
struct Complex {
    db x, y;
    
    Complex(db _x = 0.0, db _y = 0.0) { x = _x, y = _y; }

    Complex operator-(const Complex &b) const { return Complex(x - b.x, y - b.y); }
    Complex operator+(const Complex &b) const { return Complex(x + b.x, y + b.y); }
    Complex operator*(const Complex &b) const { return Complex(x * b.x - y * b.y, x * b.y + y * b.x); }
};
vector<int> rev;
int lx = 0;

/**
 * extend the length to power of 2
 * store length in &lim
 * and initialize the array rev
 */
typedef vc<Complex> C;
void INIT(C &a, int n, C &b, int m, int &lim) {
    lim = 1; lx = 0;
    while(lim <= n + m) { lim <<= 1; lx++; }
    a.resize(lim, Complex()); 
    b.resize(lim, Complex());
    rev.resize(lim);
    rep(i, 0, lim - 1) 
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (lx - 1));
}

/**
 * FFT
 * n MUST be power of 2
 * when on == 1, DFT. on == -1, IDFT
 * @param y polynomial
 * @param on DFT/IDFT
 */
void FFT(C &y, int n, int on = 1) {
    rep(i, 0, n - 1)
        if(i < rev[i]) swap(y[i], y[rev[i]]);
    for(int h = 2; h <= n; h <<= 1) {
        Complex wn(cos(2 * PI / h), sin(on * 2 * PI / h));
        for(int j = 0; j < n; j += h) {
            Complex w(1, 0);
            for(int k = j; k < j + h / 2; k++, w = w * wn) {
                Complex u = y[k], t = w * y[k + h / 2];
                y[k] = u + t;
                y[k + h / 2] = u - t;
            }
        }
    }
    // 对于保留整数预防 -0: Integer = (int)(x + 0.5);
    // 对于预防-0.00: -0.005 < x < 0 时 => 0.00
    if(on == -1) 
        rep(i, 0, n - 1) y[i].x /= n;
}
```

### 十进制大整数乘法

其他进制只需要改变数字即可

```c++
    str a, b;
    cin >> a >> b;
    vc<Complex> A, B;
    per(i, sz(a) - 1, 0) A.pb({a[i] - '0', 0});
    per(i, sz(b) - 1, 0) B.pb({b[i] - '0', 0});
    int lim;
    extend(A, B, lim);
    FFT(A, 1); FFT(B, 1);
    rep(lim) A[i] = A[i] * B[i];
    FFT(A, -1);

    rep(lim) {
        ans[i] = int(A[i].x + 0.5);
    }
	// 修改数字适合于不同进制
    rep(lim) {
        ans[i + 1] += ans[i] / 10;
        ans[i] %= 10;
    }

    while(lim >= 0 && ans[lim - 1] == 0) lim--;
    if(lim == -1) cout << 0;
    else {
        per(i, lim) cout << ans[i];
    }
    cout << endl;
```

## Geometry

### 凸包（无点记录）

```c++
struct Point {
	typedef Point P;
	db x, y;
	
	explicit Point(db x = 0, db y = 0): x(x), y(y) {}
	bool operator == (P p) const { return tie(x, y) == tie(p.x, p.y); }
	bool operator < (P p) const { return tie(x, y) < tie(p.x, p.y); }
	P operator + (P p) const { return P(x + p.x, y + p.y); }
	P operator - (P p) const { return P(x - p.x, y - p.y); }
	P operator * (db p) const { return P(x * p, y * p); }
	P operator / (db p) const { return P(x / p, y / p); }
	db dot(P p) const { return x * p.x + y * p.y; }
	db cross(P p) const { return x * p.y - y * p.x; }
	db cross(P a, P b) const { return (a - *this).cross(b - *this); }
	db dist() const { return sqrt((db)(x * x + y * y)); }
};

vc<Point> convexHull(vc<Point> pts) {
	if(sz(pts) <= 1) return pts;
	sort(pts.begin(), pts.end());
	vc<Point> h(sz(pts) + 1);
	int s = 0, t = 0;
	for(int it = 2; it--; s = --t, reverse(pts.begin(), pts.end())) {
		for(Point p: pts) {
			while(t >= s + 2 && h[t - 2].cross(h[t - 1], p) <= 0) t--;
			h[t++] = p;
		}
	}
	return {h.begin(), h.begin() + t - (t == 2 && h[0] == h[1])};
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	cout << fixed << setprecision(2);
	
	int n; cin >> n;
	vc<Point> a(n);
	rep(i, 0, n - 1) cin >> a[i].x >> a[i].y;
	vc<Point> res = convexHull(a);
	db ans = (res[sz(res) - 1] - res[0]).dist();
	rep(i, 0, sz(res) - 2) {
		ans += (res[i] - res[i + 1]).dist();	
	}
	cout << ans << '\n';
	return 0;
}
```

### 凸包（有点记录）

```c++
struct node {
	db x, y;
	friend bool operator < (node a, node b) {
		if(a.x == b.x) return a.y < b.y;
		else return a.x < b.x;
	}
};
db dist(node a, node b) { return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y)); }
db cross(node a, node b) { return a.x * b.y - a.y * b.x; }
db side(node a, node b, node c) {
	node s = node{b.x - a.x, b.y - a.y};
	node t = node{c.x - a.x, c.y - a.y};
	return cross(s, t);
}

/* 
	start point and end point count twice 
*/
vi convexHull(vc<node> &pts, vc<bool> &vis) {
	if(sz(pts) == 1) {
		vis.resize(0);
		vis.push_back(true);
		return {0, 0};
	}
	vis.resize(sz(pts));
	fill(vis.begin(), vis.end(), 0);
	sort(pts.begin(), pts.end());
	vi s; s.push_back(0);
	rep(i, 1, sz(pts) - 1) {
		while(sz(s) >= 2 && side(pts[s[sz(s) - 2]], pts[s[sz(s) - 1]], pts[i]) < 0) 
			vis[s[sz(s) - 1]] = false, s.pop_back();
		vis[i] = true, s.push_back(i);
	}
	int temp = sz(s);
	per(i, sz(pts) - 2, 0) {
		if(vis[i]) continue;
		while(sz(s) > temp && side(pts[s[sz(s) - 2]], pts[s[sz(s) - 1]], pts[i]) < 0)
			vis[s[sz(s) - 1]] = false, s.pop_back();
		vis[i] = true, s.push_back(i);
	}
	return s;
}

inline void SOLVE() {
	int n; cin >> n;
	vc<node> a(n);
	rep(i, 0, n - 1) cin >> a[i].x >> a[i].y;
	vc<bool> vis;
	vi res = convexHull(a, vis);
	
	db ans = 0;
	rep(i, 0, sz(res) - 2) {
		ans += dist(a[res[i]], a[res[i + 1]]);
	}
	cout << ans << endl;
}
```

### All

```c++
template <class T>
int sgn(T x) { return (x > 0) - (x < 0); }

template <class T>
struct Point {
    typedef Point P;
    T x, y;

    explicit Point(T x = 0, T y = 0) : x(x), y(y) {}
    bool operator<(P p) const { return tie(x, y) < tie(p.x, p.y); }
    bool operator==(P p) const { return tie(x, y) == tie(p.x, p.y); }
    P operator+(P p) const { return P(x + p.x, y + p.y); }
    P operator-(P p) const { return P(x - p.x, y - p.y); }
    P operator*(T d) const { return P(x * d, y * d); }
    P operator/(T d) const { return P(x / d, y / d); }
    T dot(P p) const { return x * p.x + y * p.y; }
    T cross(P p) const { return x * p.y - y * p.x; }
    T cross(P a, P b) const { return (a - *this).cross(b - *this); }
    T dist2() const { return x * x + y * y; }
    double dist() const { return sqrt((double)dist2()); }
    // angle to x−axis in interva l [−pi , pi ]
    double angle() const { return atan2(y, x); }
    P unit() const { return *this / dist(); } // makes d is t ()=1
    P perp() const { return P(-y, x); }       // rotates +90 degrees
    P normal() const { return perp().unit(); }
    // returns point rotated ’a ’ radians ccw around the origin
    P rotate(double a) const {
        return P(x * cos(a) - y * sin(a), x * sin(a) + y * cos(a));
    }
    friend ostream &operator<<(ostream &os, P p) {
        return os << "( " << p.x << ", " << p.y << " )";
    }
};

/* -------------------------------  Geometric primitives ------------------------------- */

/* 
    Returns the signed distance between point p and the line containing points a and b. Positive value on left side and negative
    on right as seen from a towards b. a==b gives nan 
*/
template<class P>
double lineDist(const P& a, const P& b, const P& p) {
    return (double)(b - a).cross(p - a) / (b - a).dist();
}

/*
    Returns the shortest distance between point p and the line
    segment from point s to e.
*/
double segDist(Point<double>& s, Point<double>& e, Point<double>& p) {
    if (s == e) return (p - s).dist();
    auto d = (e - s).dist2(), t = min(d, max(.0, (p - s).dot(e - s)));
    return ((p - s) * d - (e - s) * t).dist() / d;
}

/* Returns true iff p lies on the line segment from s to e */
template<class P> bool onSegment(P s, P e, P p) {
    // Use (segDist(s, e, p) <= epsilon) instead when using Point<double>.
    return p.cross(s, e) == 0 && (s - p).dot(e - p) <= 0;
}

/*
    If a unique intersection point between the line segments going
    from s1 to e1 and from s2 to e2 exists then it is returned.
    If no intersection point exists an empty vector is returned.
    If infinitely many exist a vector with 2 elements is returned,
    containing the endpoints of the common line segment
*/
template<class P> 
vector<P> segInter(P a, P b, P c, P d) {
    auto oa = c.cross(d, a), ob = c.cross(d, b),
    oc = a.cross(b, c), od = a.cross(b, d);
    // Checks if intersection is single non−endpoint point
    if (sgn(oa) * sgn(ob) < 0 && sgn(oc) * sgn(od) < 0)
        return {(a * ob - b * oa) / (ob - oa)};
    set<P> s;
    if (onSegment(c, d, a)) s.insert(a);
    if (onSegment(c, d, b)) s.insert(b);
    if (onSegment(a, b, c)) s.insert(c);
    if (onSegment(a, b, d)) s.insert(d);
    return {all(s)};
}

/*
    If a unique intersection point of the lines going through s1,e1
    and s2,e2 exists {1, point} is returned. If no intersection point
    exists {0, (0,0)} is returned and if infinitely many exists {-1,
    (0,0)} is returned
*/
template<class P>
pair<int, P> lineInter(P s1, P e1, P s2, P e2) {
    auto d = (e1 - s1).cross(e2 - s2);
    if (d == 0) // if parallel
        return {-(s1.cross(e1, s2) == 0), P(0, 0)};
    auto p = s2.cross(e1, e2), q = s2.cross(e2, s1);
    return {1, (s1 * p + e1 * q) / d};
}

/*
    Return true if the given lines are parallel
    Optional argument eps can be given
*/
template<class P>
bool lineParallel(P s1, P e1, P s2, P e2) { return (e1 - s1).cross(e2 - s2) == 0; }
template<class P>
bool lineParallel(P s1, P e1, P s2, P e2, double eps) {
    auto d = (e1 - s1).cross(e2 - s2);
    double l = (e1 - s1).dist() * eps;
    return (abs(d) < l);
}

/*
    Returns where p is as seen from s towards e. 1/0/-1 ⇔ left/on
    line/right. If the optional argument eps is given 0 is returned if p is within
    distance eps from the line
*/
template<class P>
int sideOf(P s, P e, P p) { return sgn(s.cross(e, p)); }
template<class P>
int sideOf(const P& s, const P& e, const P& p, double eps) {
    auto a = (e - s).cross(p - s);
    double l = (e - s).dist() * eps;
    return (a > l) - (a < -l);
}

/* ------------------------------- Polygons ------------------------------- */

/*
    Returns true if p lies within the polygon. If strict is true, it
    returns false for points on the boundary.
*/
template<class P>
bool inPolygon(vector<P> &p, P a, bool strict = true) {
    int cnt = 0, n = sz(p);
    rep(n) {
        P q = p[(i + 1) % n];
        if (onSegment(p[i], q, a)) return !strict;
        //or : if (segDist(p [ i ] , q , a) <= eps) return !strict;
        cnt ^= ((a.y < p[i].y) - (a.y < q.y)) * a.cross(p[i], q) > 0;
    }
    return cnt;
}

/* Returns twice the signed area of a polygon. Clockwise enumeration gives negative area */
template<class T>
T polygonArea2(vector<Point<T>>& v) {
    T a = v.back().cross(v[0]);
    rep(i, sz(v) - 1) a += v[i].cross(v[i + 1]);
    return a;
}

/* Returns the center of mass for a polygon. */
Point<double> polygonCenter(const vector<Point<double>>& v) {
    Point<double> res(0, 0); 
    double A = 0;
    for (int i = 0, j = sz(v) - 1; i < sz(v); j = i++) {
        res = res + (v[i] + v[j]) * v[j].cross(v[i]);
        A += v[j].cross(v[i]);
    }
    return res / A / 3;
}

/*
    Returns a vector with the vertices of a polygon with everything to the 
    left of the line going from s to e cut away
*/
vector<Point<double>> polygonCut(const vector<Point<double>>& poly, Point<double> s, Point<double> e) {
    vector<Point<double>> res;
    rep(sz(poly)) {
        Point<double> cur = poly[i], prev = i ? poly[i - 1] : poly.back();
        bool side = s.cross(e, cur) < 0;
        if (side != (s.cross(e, prev) < 0))
            res.push_back(lineInter(s, e, cur, prev).second);
        if (side)
            res.push_back(cur);
    }
    return res;
}

/*
    Returns a vector of the points of the convex hull in counterclockwise order. 
    Points on the edge of the hull between two
    other points are not considered part of the hull.
*/
template<class T>
vector<Point<T>> convexHull(vector<Point<T>> pts) {
    // Attetion: every point only appears ONCE
    if (sz(pts) <= 1) return pts;
    sort(all(pts));
    vector<Point<T>> h(sz(pts) + 1);
    int s = 0, t = 0;
    for (int it = 2; it--; s = --t, reverse(all(pts)))
        for (Point<T> p : pts) {
            while (t >= s + 2 && h[t - 2].cross(h[t - 1], p) <= 0) t--;
            h[t++] = p;
        }
    return {h.begin(), h.begin() + t - (t == 2 && h[0] == h[1])};
}

/*
    Determine whether a point t lies inside a convex hull (CCW
    order, with no collinear points). Returns true if point lies within the hull. If
    strict is true, points on the boundary aren’t included
*/
bool inHull(const vector<Point<ll>>& l, Point<ll> p, bool strict = true) {
    int a = 1, b = sz(l) - 1, r = !strict;
    if (sz(l) < 3) return r && onSegment(l[0], l.back(), p);
    if (sideOf(l[0], l[a], l[b]) > 0) swap(a, b);
    if (sideOf(l[0], l[a], p) >= r || sideOf(l[0], l[b], p) <= -r)
        return false;
    while (abs(a - b) > 1) {
        int c = (a + b) / 2;
        (sideOf(l[0], l[c], p) > 0 ? b : a) = c;
    }
    return sgn(l[a].cross(l[b], p)) < r;
}

/*
    Calculate the MAX distance among the points in convex hull
    using rotating calipers
    return Square of max length
*/
template<class T>
T rotatingCalipers(vector<Point<T>>& l) {
    // Attetion: every point only appears ONCE
    T res = 0;
    int cnt = 1, n = sz(l);
    rep(i, n) {
        while(l[i].cross(l[(i + 1) % n], l[cnt]) < l[i].cross(l[(i + 1) % n], l[(cnt + 1) % n]))
            cnt = (cnt + 1) % n;
        res = max(res, max((l[cnt] - l[i]).dist2(), (l[cnt] - l[(i + 1) % n]).dist2()));
    }
    return res;
}

/*
    Line-convex polygon intersection. The polygon must be ccw
    and have no collinear points. 

    lineHull(line, poly) returns a pair describing
    the intersection of a line with the polygon: • (−1, −1) if no collision, • (i, −1)
    if touching the corner i, • (i, i) if along side (i, i + 1), • (i, j) if crossing sides
    (i, i + 1) and (j, j + 1). In the last case, if a corner i is crossed, this is treated
    as happening on side (i, i + 1). The points are returned in the same order as
    the line hits the polygon. 

    extrVertex returns the point of a hull with the
    max projection onto a line.
*/
#define cmp(i,j) sgn(dir.perp().cross(poly[(i) % n] - poly[(j) % n]))
#define extr(i) cmp(i + 1, i) >= 0 && cmp(i, i - 1 + n) < 0
template <class P> 
int extrVertex(vector<P>& poly, P dir) {
    int n = sz(poly), lo = 0, hi = n;
    if (extr(0)) return 0;
    while (lo + 1 < hi) {
        int m = (lo + hi) / 2;
        if (extr(m)) return m;
        int ls = cmp(lo + 1, lo), ms = cmp(m + 1, m);
        (ls < ms || (ls == ms && ls == cmp(lo, m)) ? hi : lo) = m;
    }
    return lo;
}
#define cmpL(i) sgn(a.cross(poly[i], b))
template <class P>
array<int, 2> lineHull(P a, P b, vector<P>& poly) {
    int endA = extrVertex(poly, (a - b).perp());
    int endB = extrVertex(poly, (b - a).perp());
    if (cmpL(endA) < 0 || cmpL(endB) > 0) return {-1, -1};
    array<int, 2> res;
    rep(i, 2) {
        int lo = endB, hi = endA, n = sz(poly);
        while ((lo + 1) % n != hi) {
            int m = ((lo + hi + (lo < hi ? 0 : n)) / 2) % n;
            (cmpL(m) == cmpL(endB) ? lo : hi) = m;
        }
        res[i] = (lo + !cmpL(hi)) % n;
        swap(endA, endB);
    }
    if (res[0] == res[1]) return {res[0], -1};
    if (!cmpL(res[0]) && !cmpL(res[1]))
        switch ((res[0] - res[1] + sz(poly) + 1) % sz(poly)) {
            case 0: return {res[0], res[0]};
            case 2: return {res[1], res[1]};
        }
    return res;
}
```

## 网络流 - 最大流

### PushRelabel

$O(n ^ 2 \sqrt{m})$

```c++
/**
 * Push-relabel using the highest label selection rule and the gap
 * heuristic. Quite fast in practice. 
 * To obtain the actual flow, look at positive values only.
 */
struct PushRelabel {
    struct Edge {
        /**
         * @param ed target point
         * @param rev reversed direction edge
         * @param f current flow
         * @param c flow capacity
         */
        int ed, rev;
        ll f, c;
    };
        
    vc<vc<Edge>> g; // graph
    vll ec; // excess flow
    vc<Edge*> cur;
    vvi hs; // bucket for height
    vi H; // height

    PushRelabel(int n): g(n), ec(n), cur(n), hs(n << 1), H(n) {}

    /**
     * @param s, t  edge from s to t
     * @param cap, rcap capacity of two direction edges
     */
    void addEdge(int s, int t, ll cap, ll rcap = 0) {
        if(s == t) return;
        g[s].push_back({t, sz(g[t]), 0, cap});
        g[t].push_back({s, sz(g[s]) - 1, 0, rcap});
    }

    void addFlow(Edge& e, ll f) {
        Edge &rev = g[e.ed][e.rev];
        if(!ec[e.ed] && f) { hs[H[e.ed]].push_back(e.ed); }
        e.f += f; e.c -= f; ec[e.ed] += f;
        rev.f -= f; rev.c += f; ec[rev.ed] -= f;
    }

    ll calc(int s, int t) {
        int v = sz(g); H[s] = v; ec[t] = 1;
        vi cop(v << 1); cop[0] = v - 1;
        rep(v) cur[i] = g[i].data();
        for(Edge& e: g[s]) addFlow(e, e.c);

        for(int hi = 0;;) {
            while(hs[hi].empty()) if(!hi--) return -ec[s];
            int u = hs[hi].back(); hs[hi].pop_back();
            while(ec[u] > 0)
                if(cur[u] == g[u].data() + sz(g[u])) {
                    H[u] = 1e9;
                    for(Edge& e: g[u]) if(e.c && H[u] > H[e.ed] + 1)
                        H[u] = H[e.ed] + 1, cur[u] = &e;
                    if(++cop[H[u]], !--cop[hi] && hi < v)
                        rep(v) if(hi < H[i] && H[i] < v)
                            --cop[H[i]], H[i] = v + 1;
                    hi = H[u];
                } else if(cur[u] -> c && H[u] == H[cur[u] -> ed] + 1)
                    addFlow(*cur[u], min(ec[u], cur[u] -> c));
                else ++cur[u];
        }
    }

    bool leftOfMinCut(int a) { return H[a] >= sz(g); }
};
```

### Dinic

$O(V ^ 2 E)$

```c++
#include <bits/stdc++.h>

using ll = long long;
#define rep(i, a, b) for(int i = a; i <= b; i++)
#define per(i, a, b) for(int i = a; i >= b; i--)
#define INF (ll)(0x7fffffffffffffff)
using namespace std;
const int maxn = 5e2 + 5, maxm = 1e3 + 5;

ll n, m, s, t, u, v;
ll nxt[maxm << 1], ed[maxm << 1], head[maxn], cnt = 1;
ll dist[maxn], now[maxn];
queue<ll>mine;
ll ans, val[maxm << 1], w;

void add_edge(ll from, ll to, ll temp) {
	nxt[++cnt] = head[from];
	head[from] = cnt;
	ed[cnt] = to;
	val[cnt] = temp;
}

ll build() {
	while(!mine.empty()) mine.pop();
	rep(i, 1, n) dist[i] = INF;
	now[s] = head[s];
	dist[s] = 0;
	mine.push(s);
	while(!mine.empty()) {
		ll temp = mine.front();
		mine.pop();
		for(ll i = head[temp]; i; i = nxt[i]) {
			if(val[i] && dist[ed[i]] == INF) {
				now[ed[i]] = head[ed[i]];
				dist[ed[i]] = dist[temp] + 1;
				mine.push(ed[i]);
				if(ed[i] == t) return 1;
			}
		}
	}
	return 0;
}

ll dinic(ll temp, ll remain) {
	if(temp == t || !remain) return remain;
	ll res = 0, up;
	for(ll i = now[temp]; i; i = nxt[i]) {
		now[temp] = i;
		if(val[i] && (dist[ed[i]] == dist[temp] + 1)) {
			up = dinic(ed[i], min(remain, val[i]));
			if(!up) dist[ed[i]] = INF;
			val[i] -= up;
			val[i ^ 1] += up;
			remain -= up;
			res += up;
		}
	}
	return res;
}

int main() {
	ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
	cin >> n >> m >> s >> t;
	rep(i, 1, m) {
		cin >> u >> v >> w;
		add_edge(u, v, w);
		add_edge(v, u, 0);
	}
	while(build())
		ans += dinic(s, INF);
	cout << ans << endl;
	return 0;
}
```

## 二分图

### hopcroftKarp

$O(\sqrt{V} E)$

```c++
/**
 * Fast bipartite matching algorithm. Graph g should be a list
 * of neighbors of the left partition, and btoa should be a vector full of -1’s of
 * the same size as the right partition. Returns the size of the matching. btoa[i]
 * will be the match for vertex i on the right side, or −1 if it’s not matched.
 * @usage vi btoa(m, -1); hopcroftKarp(g, btoa);
 * @time O(\sqrt{V} E)
 */
 bool dfs(int a, int L, vector<vi>& g, vi& btoa, vi& A, vi& B) {
    if (A[a] != L) return 0;
    A[a] = -1;
    for (int b : g[a]) if (B[b] == L + 1) {
        B[b] = 0;
        if (btoa[b] == -1 || dfs(btoa[b], L + 1, g, btoa, A, B))
            return btoa[b] = a, 1;
    }
    return 0;
}

int hopcroftKarp(vector<vi>& g, vi& btoa) {
    int res = 0;
    vi A(sz(g)), B(sz(btoa)), cur, next;
    for (;;) {
        fill(all(A), 0);
        fill(all(B), 0);
        cur.clear();
        for (int a : btoa) if(a != -1) A[a] = -1;
        rep(a, sz(g)) if(A[a] == 0) cur.push_back(a);
        for (int lay = 1;; lay++) {
            bool islast = 0;
            next.clear();
            for (int a : cur) for (int b : g[a]) {
                if (btoa[b] == -1) {
                    B[b] = lay;
                    islast = 1;
                } else if (btoa[b] != a && !B[b]) {
                    B[b] = lay;
                    next.push_back(btoa[b]);
                }
            }
            if (islast) break;
            if (next.empty()) return res;
            for (int a : next) A[a] = lay;
            cur.swap(next);
        }
        rep(a, sz(g))
            res += dfs(a, 0, g, btoa, A, B);
    }
}

/**
 * MinimumVertexCover
 * Finds a minimum vertex cover in a bipartite graph. The size
 * is the same as the size of a maximum matching, and the complement is a
 * maximum independent set.
 */
 vi cover(vector<vi>& g, int n, int m) {
    vi match(m, -1);
    int res = hopcroftKarp(g, match);
    vector<bool> lfound(n, true), seen(m);
    for (int it : match) if (it != -1) lfound[it] = false;
    vi q, cover;
    rep(i, n) if (lfound[i]) q.push_back(i);
    while (!q.empty()) {
        int i = q.back(); q.pop_back();
        lfound[i] = 1;
        for (int e : g[i]) if (!seen[e] && match[e] != -1) {
            seen[e] = true;
            q.push_back(match[e]);
        }
    }
    rep(i, n) if (!lfound[i]) cover.push_back(i);
    rep(i, m) if (seen[i]) cover.push_back(n + i);
    assert(sz(cover) == res);
    return cover;
}
```

### AP增广路

$O(nm)$

```c++
// O(nm)
int jud[maxn], cube[maxn][maxn];
int l[maxn], r[maxn];
int n, m, e, u, v, w;
int ans;

int solve(int now) {
	rep(i, 1, m) {
		if(jud[i] || !cube[now][i]) continue;
		jud[i] = 1;
		if(!r[i] || solve(r[i])) {
			l[now] = i;
			r[i] = now;
			return 1;
		}
	}
	return 0;
}

int Main() {
	scanf("%d %d %d", &n, &m, &e);
	rep(i, 1, e) {
		scanf("%d %d", &u, &v);
		cube[u][v] = 1;
	}
	rep(i, 1, n) {
		memset(jud, 0, sizeof(jud));
		ans += solve(i);
	}
	printf("%d\n", ans);
	return 0;
}
```

## String

```c++
/**
 * p[i] computes the length of longest prefix
 * (abacaba -> 0010123)
 */
 vi getLost(const string &s) {
    vi p(sz(s));
    rep(i, 1, sz(s) - 1) {
        int g = p[i - 1];
        while (g && s[i] != s[g])
            g = p[g - 1];
        p[i] = g + (s[i] == s[g]);
    }
    return p;
}

/**
 * KMP full match
 * catch together
 * @param pat pattern string
 * @return indexes of full match starts from 0
 */
vi match(const string &s, const string &pat) {
    vi p = getLost(pat + '\0' + s), res;
    rep(i, sz(p) - sz(s), sz(p) - 1) 
        if (p[i] == sz(pat)) 
            res.push_back(i - 2 * sz(pat));
    return res;
}

/**
 * KMP split version
 * */
vi match_without_catch(const string &s, const string &t) {
    vi p = getLost(t), res;
    int g = 0;
    rep(i, 0, sz(s) - 1) {
        while(g && s[i] != t[g])
            g = p[g - 1];
        g += (s[i] == t[g]);
        if(g == sz(t)) res.push_back(i - sz(t) + 1);
    }
    return res;
}

/**
 * z[i] computes length of longest common prefix of s[i:] and s
 * z[0] = 0 (abacaba -> 0010301)
 */
vi Z(const string &S) {
    vi z(sz(S));
    int l = -1, r = -1;
    rep(i, 1, sz(S) - 1) {
        z[i] = i >= r ? 0 : min(r - i, z[i - l]);
        while (i + z[i] < sz(S) && S[i + z[i]] == S[z[i]])
            z[i]++;
        if (i + z[i] > r)
            l = i, r = i + z[i];
    }
    return z;
}

/**
 * For each position in a string, 
 * computes p[0][i] = half length of longest even palindrome around pos i (i at right half), 
 * p[1][i] = longest odd (half rounded down).
 * (abbbbba -> [0 0 1 2 2 1 0 0], [0 0 1 3 1 0 0])
 */
array<vi, 2> manacher(const string &s) {
    int n = sz(s);
    array<vi, 2> p = {vi(n + 1), vi(n)};
    rep(z, 0, 1) for (int i = 0, l = 0, r = 0; i < n; i++) {
        int t = r - i + !z;
        if (i < r)
            p[z][i] = min(t, p[z][l + t]);
        int L = i - p[z][i], R = i + p[z][i] - !z;
        while (L >= 1 && R + 1 < n && s[L - 1] == s[R + 1])
            p[z][i]++, L--, R++;
        if (R > r)
            l = L, r = R;
    }
    return p;
}

/**
 * Finds the lexicographically smallest rotation of a string 
 * Usage: rotate(v.begin(), v.begin() + minRotation(v), v.end())
 */ 
int minRotation(string s) {
    int a = 0, N = sz(s);
    s += s;
    rep(b, 0, N - 1) rep(k, 0, N - 1) {
        if (a + k == b || s[a + k] < s[b + k]) {
            b += max(0, k - 1);
            break;
        }
        if (s[a + k] > s[b + k]) {
            a = b;
            break;
        }
    }
    return a;
}
```

## Tarjan

### SCC

```c++
const int maxn = 1e4 + 10, maxm = 1e5 + 10;

int total, side, u, v, w, opt;
int num[maxn], dfn[maxn], low[maxn], dfn_num, col_num, col[maxn], size[maxn];
int nxt[maxm << 1], head[maxn], ed[maxm << 1], cur;
int stack[maxn], top;
bool jud[maxn];

inline void dfs(int now, int pre) {
    low[now] = dfn[now] = ++dfn_num;
    stack[++top] = now;
    jud[now] = true;
    for(int i = head[now]; i; i = nxt[i]) {
        if(ed[i] == pre) continue;
        if(!dfn[ed[i]]) {
            dfs(ed[i], now);
            low[now] = min(low[now], low[ed[i]]);
        } else if(jud[ed[i]]) 
            low[now] = min(low[now], dfn[ed[i]]);
    }
    if(dfn[now] == low[now]) {
        col_num++;
        while(stack[top] != now) {
            int temp = stack[top--];
            jud[temp] = false;
            col[temp] = col_num;
            size[col_num]++;
        }
        top--;
        jud[now] = false;
        col[now] = col_num;
        size[col_num]++;
    }
}   
```

### cut point

```c++
const int maxn = 2e4 + 10, maxm = 1e5 + 10;

int total, side, u, v, w, opt, ans, root;
int nxt[maxm << 1], head[maxn], ed[maxm << 1], cur;
bool jud[maxn];
int dfn[maxn], low[maxn], dfn_num;

inline void dfs(int now, int pre) {
    dfn[now] = low[now] = ++dfn_num;
    int flag = 0;
    for(int i = head[now]; i; i = nxt[i]) {
        if(ed[i] == pre) continue;
        if(!dfn[ed[i]]) {
            dfs(ed[i], now);
            low[now] = min(low[now], low[ed[i]]);
            if(low[ed[i]] >= dfn[now]) {
                flag++;
                if(now != root || flag > 1)
                    jud[now] = true, ans++;
            }
        } else { low[now] = min(low[now], dfn[ed[i]]); }
    }
}
```

### bridge

```c++
const int maxn = 2e4 + 10, maxm = 1e5 + 10;

int nxt[maxm << 1], head[maxn], ed[maxm << 1], cur;
int dfn[maxn], low[maxn], dfn_num;
int siz[maxn];
bool jud[maxm << 1];
int total, side, u, v, w, opt, ans;

inline void dfs(int now, int pre) {
    dfn[now] = low[now] = ++dfn_num;
    for(int i = head[now]; i; i = nxt[i]) {
        if(ed[i] == pre) continue;
        if(!dfn[ed[i]]) {
            dfs(ed[i], now);
            low[now] = min(low[now], low[ed[i]]);
            siz[now] += siz[ed[i]];
            if(low[ed[i]] > dfn[now]) { jud[i] = jud[i ^ 1] = true; ans++; }
        } else low[now] = min(low[now], dfn[ed[i]]);
    }
}
```

## ex_gcd

> ax + by = c 正整数解

```c++
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll test, a, b, c, x, y, r, d, cnt;

inline ll exgcd(ll a, ll b) {
    if (b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    ll d = exgcd(b, a % b);
    ll t = x;
    x = y;
    y = t - a / b * y;
    return d;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    ll t; cin >> t;
    while (t--) {
        ll a, b, c; cin >> a >> b >> c;
        ll d = exgcd(a, b);
        if (c % d)
        { // 不满足裴蜀定理，直接输出-1
            cout << -1 << endl;
            continue;
        }
        x = x * c / d, y = y * c / d; // 求出 x0 和 y0，tx 和 ty
        ll tx = b / d, ty = a / d;
        ll k = ceil((1.0 - x) / tx); // 求出 k
        x += tx * k;
        y -= ty * k;
        if (y <= 0)
        {
            ll ymin = y + ty * 1ll * ceil((1.0 - y) / ty);
            cout << x << " " << ymin << endl;
        } else {
            cout << (y - 1) / ty + 1 << " ";
            cout << x << " ";
            cout << (y - 1) % ty + 1 << " ";
            cout << x + (y - 1) / ty * tx << " ";
            cout << y << " ";
            cout << endl;
        }
    }
    return 0;
}
```

## 同余方程

> $ax\equiv 1 \quad mod \,b$

```c++
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll test, a, b, c, x, y, r, d, cnt;

inline ll exgcd(ll a, ll b) {
    if (b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    ll d = exgcd(b, a % b);
    ll t = x;
    x = y;
    y = t - a / b * y;
    return d;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    ll a, b, c = 1; cin >> a >> b;
    ll d = exgcd(a, b);
    x = x * c / d, y = y * c / d; // 求出 x0 和 y0，tx 和 ty
    ll tx = b / d, ty = a / d;
    ll k = ceil((1.0 - x) / tx); // 求出 k
    x += tx * k;
    y -= ty * k;
    cout << x << endl;
    return 0;
}
```

## 判断多条线段中是否存在相交

可能需要使用**平衡树**

**线段的顺序**由**叉积**得出

![image-20241217161506191](C:\Users\12298\AppData\Roaming\Typora\typora-user-images\image-20241217161506191.png)

![image-20241217161511182](C:\Users\12298\AppData\Roaming\Typora\typora-user-images\image-20241217161511182.png)

![image-20241217161524243](C:\Users\12298\AppData\Roaming\Typora\typora-user-images\image-20241217161524243.png)

## 单纯的蝴蝶变换

```c++
typedef vc<Complex> C;
void INIT(C &a, int n, C &b, int m, int &lim) {
    rev.resize(lim);
    rep(i, 0, lim - 1) 
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (lx - 1));
}

void FFT(C &y, int n, int on = 1) {
    rep(i, 0, n - 1)
        if(i < rev[i]) swap(y[i], y[rev[i]]);
}

inline void SOLVE() {

    INT(n);
    C a(n);
    rep(n) cin >> a[i].x;
    int lim = n;
    lx = (int)(log2(n));
    INIT(a, n, a, n, lim);
    FFT(a, lim, 1);
    rep(lim) cout << (int)(a[i].x + 0.5) << " ";
    cout << endl;
}

```

## 单纯DFT模拟

```c++
typedef vc<Complex> C;
void INIT(C &a, int n, C &b, int m, int &lim) {
    lim = 4; lx = 2;
    rev.resize(lim);
    rep(i, 0, lim - 1) 
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (lx - 1));
}

inline void FFT(...) {...}

inline void SOLVE() {

    C a = {Complex(3, 0), Complex(0, 0), Complex(-1, 0), Complex(2, 0)};
    int lim;
    INIT(a, 4, a, 4, lim);
    FFT(a, 4, 1);
    for(auto x: a) {
        cout << x.x << " " << x.y << endl;
    }    

}
```

## 单纯的IDFT

```c++
typedef vc<Complex> C;
void INIT(C &a, int n, C &b, int m, int &lim) {
    rev.resize(lim);
    rep(i, 0, lim - 1) 
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (lx - 1));
}

void FFT(C &y, int n, int on = 1) {
	...
    if(on == -1) 
        rep(i, 0, n - 1) 
            y[i].x /= n, y[i].y /= n;
}

inline void SOLVE() {

    INT(k); int n = 1 << k;
    C a(n);
    int lim = n; lx = k;
    rep(n) cin >> a[i].x;
    INIT(a, n, a, n, lim);
    FFT(a, n, -1);
    rep(n) {
        if(a[i].x > -0.005 && a[i].x < 0) cout << "0.00" << " ";
        else cout << a[i].x << " ";
        if(a[i].y > -0.005 && a[i].y < 0) cout << "0.00" << endl;
        else cout << a[i].y << endl;
    }
}
```

## 有限状态自动机

```c++
 vi getLost(const string &s) {
    vi p(sz(s));
    rep(i, 1, sz(s) - 1) {
        int g = p[i - 1];
        while (g && s[i] != s[g])
            g = p[g - 1];
        p[i] = g + (s[i] == s[g]);
    }
    return p;
}

inline void SOLVE() {

    str s; cin >> s;
    int n = sz(s);
    vvi lost(n + 1, vi(26));
    vi p(n);
    lost[0][s[0] - 'a'] = 1;
    rep(i, 1, n) {
        int g = p[i - 1];
        rep(j, 0, 25) {
            if(i != n && ('a' + j) == s[i]) {
                lost[i][j] = i + 1;
                continue;
            }
            int t = g;
            while(t && ('a' + j) != s[t])
                t = p[t - 1];
            lost[i][j] = t + (('a' + j) == s[t]);
        }
        if(i != n) {
            while(g && s[i] != s[g]) 
                g = p[g - 1];
            p[i] = g + (s[i] == s[g]);
        }
    }
    int res = 0;
    rep(i, n + 1) rep(j, 26) {
        res += lost[i][j];
    }
    wt(res);

}
```

## 多重背包

```c++
typedef struct {
    int cost, val;
} node;
node arr[maxn];
int dp[maxn];

inline void SOLVE() {

    INT(n, m);
    int cnt = 0;
    rep(j, n) {
        INT(k, c, d);
        for(int i = 0; i < 18; i++) {
            if(k > (1 << i)) {
                arr[++cnt] = {c * (1 << i), d * (1 << i)};
                k -= (1 << i);
            }
        }
        if(k != 0) arr[++cnt] = {c * k, d * k};
    }

    rep(i, 0, m) dp[i] = 0;
    rep(i, 1, cnt) {
        per(j, m, arr[i].cost) {
            dp[j] = max(dp[j], dp[j - arr[i].cost] + arr[i].val);
        }
    }

    wt(dp[m]);
}
```

## 最长公共子串

```c++
inline int calc1(vs &s) {
    vvi f(sz(s[0]) + 1, vi(sz(s[1]) + 1));
    int ans = 0;
    rep(sz(s[0])) {
        rep(j, sz(s[1])) {
            if(s[0][i] == s[1][j]) {
                f[i + 1][j + 1] = f[i][j] + 1;
            } else f[i + 1][j + 1] = 0;
            ans = max(ans, f[i + 1][j + 1]);
        }
    }
    return ans;
}
```

## 最长公共子序列

```c++
inline int calc2(vs &s) {
    vvi f(sz(s[0]) + 1, vi(sz(s[1]) + 1));
    rep(sz(s[0])) {
        rep(j, sz(s[1])) {
            f[i + 1][j + 1] = f[i][j];
            if(s[0][i] == s[1][j]) {
                f[i + 1][j + 1] = max(f[i + 1][j + 1], f[i][j] + 1);
            }
            f[i + 1][j + 1] = max(f[i + 1][j + 1], max(f[i + 1][j], f[i][j + 1]));
        }
    }
    return f[sz(s[0])][sz(s[1])];
}
```

## OBST

```c++
    INT(n);
    vi p(n + 2);
    vll pre(n + 2);
    vvll f(n + 2, vll(n + 2));
    vvi child(n + 2, vi(2, -1));
    vvi fa(n + 2, vi(n + 2));

    rep(i, 1, n) cin >> p[i], pre[i] = pre[i - 1] + p[i], f[i][i] = p[i], fa[i][i] = i;
    
    rep(len, 2, n) {
        rep(l, 1, n) {
            int r = l + len - 1;
            if(r > n) break;

            f[l][r] = 0x3f3f3f3f3f3f3f3f;
            
            rep(k, l, r) {
                ll temp = f[l][k - 1] + f[k + 1][r] + pre[r] - pre[l - 1];
                if(f[l][r] > temp) {
                    fa[l][r] = k;
                    f[l][r] = temp;
                }
            }
        }
    }

    auto DFS = [&](auto &&self, int l, int r) -> int {
        // cout << l << " " << r << endl;
        if(l > r) ret -1;
        int root = fa[l][r];
        child[root][0] = self(self, l, root - 1);
        child[root][1] = self(self, root + 1, r);
        return root;
    };

    cout << f[1][n] << '\n';
    DFS(DFS, 1, n);

    rep(i, 1, n) {
        cout << child[i][0] << " " << child[i][1] << '\n';
    }
```

## 流水线最小字典序调度

```c++
    INT(m, n);
    vvll p(n + 2, vll(m + 2));
    vvll t(n + 2, vll(n + 2));
    rep(i, 1, n) rep(j, 1, m) cin >> p[i][j];
    rep(i, 1, n) rep(j, 1, n) cin >> t[i][j];

    vvll f(m + 2, vll(n + 2, 0x3f3f3f3f3f3f3f3f));
    vvi fa(m + 2, vi(n + 2));
    
    rep(i, 1, n) f[m][i] = p[i][m];

    per(i, m - 1, 1) rep(j, 1, n) {
        rep(k, 1, n) {
            ll temp = p[j][i] + f[i + 1][k] + t[j][k];
            if(temp < f[i][j]) {
                f[i][j] = temp;
                fa[i][j] = k;
            }
        }
    }

    vi q(m + 1);
    ll ans = 0x3f3f3f3f3f3f3f3f;
    rep(i, 1, n) {
        if(f[1][i] < ans) {
            ans = f[1][i];
            q[1] = i;
        }
    }
    wt(ans);

    rep(i, 1, m - 1) {
        q[i + 1] = fa[i][q[i]];
    }

    rep(i, 1, m) {
        cout << "Station" << i << ": Line" << q[i] << '\n';
    }
```

## 最长不下降子序列

$O(n \log n)$

```c++
    INT(n);
    vi a(n), f;
    vpii arr(n);
    cin >> arr;
    sort(all(arr));
    rep(n) a[i] = arr[i].second - arr[i].first;
    rep(i, n) {
        int loc = upper_bound(all(f), a[i]) - f.begin();
		// 判断是否可以加入第一个点，题目特殊要求
        if(loc == 0 && a[i] < 0) continue;

        if(loc == sz(f)) f.pb(a[i]);
        else 
            f[loc] = a[i];
    }
    wt(sz(f));
```

